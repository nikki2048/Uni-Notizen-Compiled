{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Tags","n":1}}},{"i":2,"$":{"0":{"v":"My","n":1}}},{"i":3,"$":{"0":{"v":"Example","n":1}}},{"i":4,"$":{"0":{"v":"2. Semester","n":0.707}}},{"i":5,"$":{"0":{"v":"Lineare Algebra","n":0.707}}},{"i":6,"$":{"0":{"v":"Fosap","n":1},"1":{"v":"\r\n### Kapitel 0 - Einführung\r\n- [[§1 - Organisatorisches|2-semester.fosap.kapitel-0.organisatorisches]]\r\n\r\n### Kapitel 1 - ???\r\n- [[§1 - Deterministische Endliche Automaten|2-semester.fosap.kapitel-1-dea]]\n","n":0.243}}},{"i":7,"$":{"0":{"v":"Kapitel 1-Deterministische Endliche Automaten","n":0.5},"1":{"v":"\n\r\n## Begriffdefinitionen: \r\n\r\n**Sprache:** Menge aller Wörter, die einen Automaten zum Endzustand bringen\r\n\r\n\r\n\r\n**Alphabet:** Buchstaben, Symbole (Σ), Σ* Menge aller Wörter über Alphabet\r\n\r\n**Wort:** Endliche Folge von Zeichen, Ɛ: leeres Wort\r\n\r\n**Lauf:** Auswertung eines Wortes auf einem Automaten\r\n\r\n \r\n\r\n| Wichtige Symbole| Beschreibung |\r\n| ----------- | ----------- |\r\n| $\\sum$* | Menge aller Wörter eines Alphabets |\r\n| $\\epsilon$ | leeres Wort |\r\n\r\n---\r\n\r\n## DFA's Definition:\r\n\r\n**DFA's Formal**: 5-Tupel (Q, Σ, δ, q0, F)\r\n\r\n\r\n1. $Q$: Menge aller Zustände \r\n2. $\\sum$:  Eingabealphabet \r\n3. $\\varsigma$: Q x Σ -> Q (Transitionsfunktion)\r\n4. $q_0 \\in Q$:  Anfangszustand \r\n5.  $F$:  Menge aller Endzustände \r\n\r\n---\r\n**Wichtig:**\r\n\r\n* leere Sprache $\\emptyset$ hat **kein** Inhalt\r\n* Sprache $\\{\\varepsilon\\}$ hat **ein** Element (das leere Wort) als Inhalt\r\n---\r\n","n":0.097}}},{"i":8,"$":{"0":{"v":"Kapitel 0","n":0.707},"1":{"v":"\n\r\n//TODO","n":1}}},{"i":9,"$":{"0":{"v":"Organisatorisches","n":1}}},{"i":10,"$":{"0":{"v":"Einführung","n":1}}},{"i":11,"$":{"0":{"v":"Datenstrukturen und Algorithmen","n":0.577},"1":{"v":"\r\n### Kapitel 0 - Einführung\r\n- [[§1 - Organisatorisches|2-semester.dsal.kapitel-0.organisatorisches]]\r\n- [[§2 - Überblick|2-semester.dsal.kapitel-0.überblick]]\r\n\r\n### Kapitel 1 - Datenstrukturen\r\n- [[§1 - Abstrakte Datentypen | 2-semester.dsal.kapitel-1.abstrakte-datentypen]]\r\n- [[§2 - Lineare Strukturen | 2-semester.dsal.kapitel-1.lineare-strukturen]]\r\n- [[§3 - Bäume|2-semester.dsal.kapitel-1.bäume]]\n","n":0.183}}},{"i":12,"$":{"0":{"v":"Kapitel 1","n":0.707}}},{"i":13,"$":{"0":{"v":"Prioritätschlangen","n":1},"1":{"v":"\n## Überblick\n\n- Warteschlange mit Vordrängeln\n- Einfügen am Ende der Schlange \n- Jedes Element hat eine Priorität\n- Deq() liefert immer das Element mit der *höchsten* Priorität\n\n\n### Spezifikationen\n\n- Elemente: $X \\in W' = W \\times R$\n- Wertebereich: $L = \\{\\} \\cup W' \\cup W'^2 \\cup W'^3 \\cup \\ldots$\n- Create: $\\rightarrow L$\n- Enq: $W' \\times L \\rightarrow L$\n- **Enqq** $W' \\times L \\rightarrow L$\n- Deq: $L \\rightarrow L$   \n- Get: $L \\rightarrow W'$\n- Empty: $L \\rightarrow Bool$\n\n\n\n### Heap-Bedingungen\n\n**<u>Idee:</u>**\n\n Front und back Pointer/Counter nutzen \n- Binäre Bäume: Schneller Elementzugriff\n- Array- Implementierung vollständiger Bäume kombiniert die beiden Vorteile.\n\n\n- Neue Sortier-Vorschirft der Knoten im Baum: \n- Für alle Knoten $T = Node(L,X,R$ muss gelten: \n    \n    \n    > max_prio(L) $\\leq$ prio[X] <br>\n     max_prio(R) $\\leq$ prio[X]\n\n- Wurzelknoten: Element mit der maximalen Priorität\n- Sortierung der Elemente nur entlamg der Pfade im Binärbaum\n\n### Effiziente Implementierung\n\n<u>Arrayimplementierung:</u>\n\n- Front Pointer bei front = 1 fest\n- Element mit max. Priorität in S[1]\n- Back-Pointer variable \n- Einfügen in S[back]\n\n> Priorisierte Binärbaumbeziehungen: <br>\n$(i) S[i] \\rightarrow S[2*i], S[2*i+1]$ <br>\nmit <br>\n$(ii) prio(S[i]) \\geq max(prio(S[2i]), prio(S[2i+1])$\n\n![Array-Implemetierung](/assets/images/Prioritaetsschlangen.png){width: 100%, max-width: 645px}\n    \n#### Einfügen in eine Prioritätschlangen\n- Falls die obige Bedingung nicht erfüllt ist wird das Element soweit nach vorne getauscht bis es an der richtigen Position ist\n\n>  $Index$ (des aktuellen Knotens)$/2$ um auf den Elternknoten zu gelangen\n\n#### Löschen aus einer Prioritätschlange\n\n- Vorderstes Element wird gelöscht\n- Letztes Element wird nach vorne kopiert\n- Von Vorne nach Hinten vertauschen damit obige Bedingung wieder erfüllt ist\n\n> $2^{Index}$ bzw. $2^{Index+1} -1$ des aktuellen Elementes, um auf die Kindknoten zu gelangen","n":0.064}}},{"i":14,"$":{"0":{"v":"Lineare Strukturen","n":0.707},"1":{"v":"\n\r\n- Sequenz $\\{x_1,\\ldots,x_n\\}$ von beliebigen Datenobjekten $x_i$\r\n- Typische Operationen (Beispiele)\r\n  - Füge $y$ am Anfang / am Ende / hinter $x_i$ ein\r\n  - Ersetze $x_i$ durch $y$\r\n  - Entferne $x_i$\r\n\r\n## Listen\r\n- $L = \\{x_1, \\ldots, x_n\\}$\r\n- Zugriff auf beliebige Elemente $x_i$\r\n  - Per Index (random access)\r\n    - Get(i)\r\n  - Per Marker (sequential access)\r\n    - GetFirst()\r\n    - GetNext()\r\n    - GetPrevious()\r\n\r\nRandom access:\r\n- Typischerweise implementierung durch Arrays L[]\r\n- Get(i) = L[i]\r\n- Nachteile:\r\n  - Elemente löschen erzeugt Lücken oder alle Elemente mit höherem Index müssen verschoben werden (garbage collection)\r\n  - Statische Obergrenze für Listenlänge\r\n\r\nSequential Access:\r\n- Implementierung durch Pointer oder Container\r\n- Marker zeigt auf aktuelle Position\r\n- Nachteil: Elementzugriff erfordert lineare Suche\r\n  - kann meistens durch \"for each\" vermieden werden\r\n- Vorteil: Beliebiges Erweitern und Löschen\r\n\r\nSpezifikation:\r\n- Wertebereich: $L = \\{\\} \\cup W \\cup W^2 \\cup W^3 \\cup \\ldots$\r\n- Create: $\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\r\n- Get: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow W$\r\n- Next: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\r\n- Insert: $W \\times L \\rightarrow L$\r\n- Delete: $L \\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\r\n- Reset: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\r\n- Empty: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow Bool$\r\n- IsLast: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow Bool$\r\n\r\n<u>Achtung:</u> der Marker beschreibt einen *Zustand*, was sich mit *funktionalen* Axiomen schlecht formulieren lässt.\r\n\r\n<u>Standard-Trick:</u> Führe ein zusätzliches Prädikat _Insert*_ ein, das aber keine eigene Listen-Funkttion darstellt:\r\n\r\n```text\r\nInsert(x,Insert(y,Insert(z,Create())))\r\n    = {X,y,z}\r\n\r\nInsert*(x,Insert(y,Insert(z,Create())))\r\n    = {x,Y,z}\r\n\r\nInsert*(x,Insert*(y,Insert(z,Create())))\r\n    = {x,y,Z}\r\n```\r\n\r\n**Satz**\r\n\r\nJede Liste hat die Form\r\n\r\nInsert*($x_1,$ $\\ldots$ Insert*($x_i$,Insert($x_i+1$, Insert($x_n$, Create()))))\r\n\r\n<u> Beweis durch vollständige Induktion </u>\r\n - Induktionsanfang: Create()\r\n - Induktionsschritt: insert(), insert*()\r\n\r\n--- \r\nModifikation am Listenanfang für Einfüge und Löschungsoperationen: \r\n\r\n- **Anchor:** \r\n  - Erstes Element enthält keine Daten\r\n  - Platzhalter für Einfüge-/Löschoperationen\r\n\r\n### Doppelt verkettete Listen\r\n\r\n- Flexibler Zugriff (upstream/ downstream)\r\n  - Next(), Prev()\r\n\r\n- Marker zeigt auf aktuelle Element\r\n  - Delete-Operationen beziehen sich auf das aktuelle Element und nicht wie bisher auf das folgende Element\r\n  - Insert-Operationen fügen ein Element *nach* dem aktuellen Element ein\r\n\r\n- Spezialfälle an Listenenden\r\n  - **Anchor** am Listenanfang \r\n  - **Sentinel** am Listenende \r\n\r\n## Warteschlangen \r\n\r\n- Einfügen nur am Ende\r\n- Auslesen / Entfernen nur am Anfang\r\n- \"First in, first out\" (FIFO-Prinzip)\r\n\r\nSpezifikationen: \r\n\r\n- Wertebereich: $L = /{/} \\cup W \\cup W^2 \\cup W^3 \\ldots$\r\n- Create: $\\rightarrow L$\r\n- Enq: $W \\times L \\rightarrow L$\r\n- Deg: $L \\rightarrow L$\r\n- Get : $L \\rightarrow W$\r\n- Empty: $L \\rightarrow Bool$\r\n\r\n**Satz**\r\n\r\nJede Warteschlange hat die Form: \r\n\r\nEnq($x_n,$ Enq($x_{n-1}$,$\\ldots$ Enq($x_1$, Create())))\r\n\r\n<u> Beweis durch vollständige Induktion </u>\r\n\r\n- Induktionsanfang: Create()\r\n- Induktionsschritt: Jede andere Operation (Enq, Deq) erhält diese Form\r\n\r\n**Pointer-Implementierung**:\r\n\r\n- Interner Pointer entfällt\r\n- Front und Back Pointer: \r\n  - Front Pointer: Anchor\r\n  - Back Pointer: Sentinel\r\n\r\n**Array-Implementierung:** \r\n- Da nur am Anfang eingefügt und am Ende ist keine *garbage collection* notwendig\r\n- Maximale Länge wird als bekannt vorrausgesetzt\r\n\r\n## Stack \r\n- Liste mit eingeschränkten Funktionalitäten \r\n- Einfügen nur am Anfang\r\n- Auslesen / Entfernen nur am Anfang\r\n- \"Last in, first out\"  (LIFO)\r\n\r\nSpezifikationen: \r\n- Wertebereich: $L = /{ \\cup W \\cup W^2 \\cup W^3 \\cup/}$\r\n- Create: $\\rightarrow L $\r\n- Push: $W \\times L \\rightarrow L$\r\n- Pop: $L \\rightarrow L$\r\n- Top: $L \\rightarrow W$\r\n- Empty: $L \\rightarrow Bool$\r\n\r\n\r\n*Satz*\r\nJeder Stack hat die Form: \r\n\r\n\r\nPush($x_1$, Push($x_2$, $\\ldots$ Push($x_n$, Create())))\r\n\r\n<u> Beweis durch vollstädnige Induktion </u>\r\n- Induktionsanfang: Create()\r\n- Induktionsschritt: Jede andere Operation erhält diese Form\r\n\r\n**Array-Implemetierung:**\r\n- Da nur am Anfang eingefügt und gelöscht wird, ist keine garbage collection notwendig \r\n- Maximale Größe wird als bekannt vorausgesetzt\r\n\r\n<u>Merke</u>\r\n- rekursive Algorithmen lassen sich in der Regel mit einer Stack-Datenstruktur auch iterativ formulieren. \r\n- Das LIFO-Prinzip entspricht der Abarbeitungsreihenfolge der geschachtelten Prozeduren (was zuletzt aufgerufen wird, wird als erstes bearbeitet)\r\n","n":0.043}}},{"i":15,"$":{"0":{"v":"Bäume","n":1},"1":{"v":"\n\r\n## Überblick\r\n**Hierarchische Datenstruktur:**\r\n- Zusammenfassung von Gruppen\r\n- Eindeutige Schachtelung [1:n]\r\n\r\n**Typische Anwendungen:**\r\n- Such / Entscheidungsprobleme\r\n- Strukturierte Aufzählung\r\n- Komplexitätsreduktion\r\n\r\n\r\n### Definition\r\n- Menge von **Knoten** $V = \\{ v_1, \\ldots, v_2 \\}$, wobei $v_i \\in W$ beliebiger Datentyp.\r\n- Menge von **Kanten** $E = \\{(a_1,b_1), \\ldots ,(a_m,b_m) \\}$, wobei $a_i,b_i \\in W$, beliebiger Datentyp\r\n- Falls $(a,b) \\in E$, dann ist:\r\n  - $v_a$ Vorgänger von $v_b$\r\n  - $v_b$ Nachfolger von $v_a$\r\n<br><br>\r\n\r\n- Eine Folge von Kanten $(i_1,i_2),(i_2,i_3), \\ldots , (i_{k1}, i_k)$ heißt **Pfad** von $v_{i1}$ nach $v_{ik}$\r\n- Für $i_1 = i_k$ ist dieser Pfad ein **Zyklus**\r\n- Ein Baum $B = (V,E)$ besteht aus einer Menge von Knoten $V$ und einer Menge von Kanten $E$, so dass gilt:\r\n  - Es gibt keine Zyklen\r\n  - Jeder normale Knoten hat genau einen Vorgänger\r\n  - Es existiert genau ein Wurzelknoten, der keinen Vorgänger hat\r\n<br><br>\r\n\r\n- Der eine Knoten ohne Vorgänger heißt **Wurzelknoten**\r\n- Knoten ohne Nachfolger heißen **Blätter**\r\n- Knoten mit Nachfolgern heißen **innere Knoten**\r\n<br><br>\r\n\r\n- Die **Tiefe** eines Knotens ist gleich der Länge des zugehörigen Pfades von der Wurzel\r\n- Die **Höhe** eines Baumes ist gleich der Tiefe des tiefsten Knotens\r\n- Der **Grad** eines Knotens ist die Anzahl seiner Nachfolger\r\n\r\n\r\n### Abgeleitete Eigenschaften\r\n- Für jeden Knoten existert ein eindeutiger Pfad, der ihn mit dem Wurzelknoten verbindet. \r\n- Jeder Knoten ist Wurzelknoten eines zugehörigen **Sub-Baumes**\r\n","n":0.07}}},{"i":16,"$":{"0":{"v":"Abstrakte Datentypen","n":0.707},"1":{"v":"\n\r\nAbstrakte Datentypen spezifizieren *Form und Funktionalität* der zu verarbeitenden Daten.\r\n\r\nBeispiel (Addition zweier Zeiten):\r\n- Datenobjekte, Datenfelder\r\n  - Zeit: `hh:mm:ss`\r\n- Funktionen:\r\n  - Add: `Zeit` $\\times$ `Zeit` $\\rightarrow$ `Zeit`\r\n- Axiome:\r\n  - `Add` $([h_1, m_1, s_1], [h_2, m_2, s_2]) =$ <br>\r\n  $[(h_1 + h_2 + (m_1 + m_2 + (s_1 + s_2) / 60) / 60) \\: \\% \\: 24$, <br> $(m_1 + m_2 + (s_1 + s_2) / 60) \\: \\% \\: 60$, <br> $(s_1+s_2)) \\: \\% \\: 60]$\r\n\r\n## Datentypen\r\n- Aufzählungstypen (bool, enum)\r\n  - 0-Dimensional\r\n  - Endlicher Wertebereich (vollständige Spezifikation durch Tabellen möglich)\r\n  - [[Beispiel | 2-semester.dsal.kapitel-1.abstrakte-datentypen.beispiele#aufzählungstypen-bool]]\r\n- Skalare Typen (char, int, float, ...)\r\n  - 1-Dimensional\r\n  - [[Beispiel | 2-semester.dsal.kapitel-1.abstrakte-datentypen.beispiele#skalare-typen-integer]]\r\n- Zusammengesetzte Typen (struct, class)\r\n  - n-Dimensional\r\n  - Endliche / Feste zusammengesetzte Typen\r\n    - k-dim. Vektoren (Tupel)\r\n    - Addressen-Eintrag\r\n- Lineare Strukturen (list, queue, stack)\r\n  - [1:1] Beziehung\r\n  - [[Beispiel | 2-semester.dsal.kapitel-1.abstrakte-datentypen.beispiele#lineare-strukturen]]\r\n- Bäume\r\n  - [1:n] Beziehung\r\n  - [[Beispiel | 2-semester.dsal.kapitel-1.abstrakte-datentypen.beispiele#baumstrukturen]]\r\n- Graphen - n-m Strukturen\r\n  - [n:m] Beziehung\r\n  - Beliebige *topologische* Struktur\r\n  - Nachbarschafsbeziehungen zwischen Knoten\r\n  - Wichtige Spezialfälle:\r\n    - Planare Graphen\r\n    - Gerichtete Graphen\r\n    - Zyklenfreie Graphen\r\n\r\n## Warum abstrakt?\r\n- Keine Festlegung, wie die jeweiligen Funktionen *implementiert* werden (\"Transparenz\")\r\n- Axiome beschreiben *statische* Beziehungen (\"$=$\" vs. \"$:=$\")","n":0.073}}},{"i":17,"$":{"0":{"v":"Beispiele","n":1},"1":{"v":"\n\r\n## Aufzählungstypen (Bool)\r\n0-Dimensional\r\n\r\n- Wertebereich: $\\{true, false\\}$\r\n- $\\neg : bool \\times bool \\rightarrow bool$\r\n- $\\land : bool \\times bool \\rightarrow bool$\r\n- $\\lor : bool \\times bool \\rightarrow bool$\r\n\r\n$\\neg \\: true = false, \\neg \\: false = true$\r\n\r\n| $\\land$ | True | False |\r\n| ------- | ---- | ----- |\r\n| **True**    | True | False |\r\n| **False**   | False| False |\r\n<br>\r\n\r\n| $\\land$ | True | False |\r\n| ------- | ---- | ----- |\r\n| **True**    | True | True  |\r\n| **False**   | True| False  |\r\n\r\n## Skalare Typen (Integer)\r\n1-Dimensional\r\n\r\n- Wertebereich: $\\mathbb{Z} = \\mathbb{N}_{+} \\cup \\{0\\} \\cup -\\mathbb{N}_{+}$\r\n- $+ : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $- : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $- : \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $\\times : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $\\div : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n\r\nAxiome:\r\n- $+(0,b) = b$\r\n- $+(a+1,b) = +(a,b)+1 \\:\\:\\:\\:$     (count down to 0)\r\n- $+(a-1,b) = +(a,b)-1 \\:\\:\\:\\:$     (count up to 0)\r\n<br><br>\r\n- $-(b,b) = 0$\r\n- $-(a+1,b) = -(a,b)+1$\r\n- $-(a-1,b) = -(a,b)-1$\r\n<br><br>\r\n- $-(b) = -(0,b)$\r\n<br><br>\r\n- $\\times(0,b) = 0$\r\n- $\\times(a+1,b) = +(\\times(a,b),b)$\r\n- $\\times(a-1,b) = -(\\times(a,b),b)$\r\n<br><br>\r\n- $\\div(a,0) = \\text{ERR}$\r\n- $\\div(a,b) = 0$ if $|a| < |b|$\r\n- $\\div(a+b,b) = \\div(a,b)+1$\r\n- $\\div(a-b,b) = \\div(a,b)-1$\r\n\r\n## Lineare Strukturen\r\n- Beliebige Sequenz von Basisobjekten (skalare / zusammengesetzte Typen) mit variabler Länge\r\n  - Arrays\r\n  - Listen (einfch / doppelt verkettet)\r\n  - Queue (FIFO)\r\n  - Stack (LIFO)\r\n- Unterscheiden sich im Wesentlichen in der Zugriffsfunktionalität\r\n\r\n### Beispiel (Sequenz):\r\n- Wertebereich: $W = \\{\\} \\cup N \\cup N^2 \\cup N^3 \\cup \\ldots$\r\n  - $\\neq 2^N$\r\n- Create: $\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow W$\r\n- Append: $N \\times W \\rightarrow W$\r\n- Remove: $N \\times W \\rightarrow W$\r\n\r\nAxiome:\r\n- Create() = $\\{\\}$\r\n- Append($X,\\{y_1, \\ldots, y_n\\}$) = $\\{y_1,\\ldots,y_n,X\\}$\r\n  - Append(z,Append(y,Append(x,Create()))) = $\\{x,y,z\\}$\r\n- Remove(x,Create()) = Create()\r\n- Remove(x,Append(x,z)) = z\r\n- Remove(x,Append(y,z)) = Append(y,Remove(x,z)) *if x $\\neq$ y*\r\n\r\n## Baumstrukturen\r\n- Hierarchische Strukturen\r\n- Mutter / Kind-Beziehung [1:n]\r\n- Keine Zyklen\r\n- Eindeuttige Vorfahren\r\n\r\nAxiome:\r\n- Insert(x,Create()) = Node(Create(),x,Create())\r\n- Insert(x,Node(left,x,right)) = Node(left,x,right)\r\n- Insert(x,Node(left,y,right)) = <br>\r\n    if x < y: Node(Insert(x,left), y, right) <br>\r\n    if x > y: Node(left,y,Insert(x,right))\r\n","n":0.057}}},{"i":18,"$":{"0":{"v":"Kapitel 0","n":0.707}}},{"i":19,"$":{"0":{"v":"Überblick","n":1},"1":{"v":"\n\r\n## Positionsbestimmung\r\n\r\nInformatik = Wissenschaft von der *algorithmischen* Problemlösung\r\n- Gegeben: Problem(klasse)\r\n- Gesucht: Lösungsprozedur ((automatisierbare) Lösung aus elementaren Schritten)\r\n\r\n## Definitionen\r\n\r\nRepräsentation / Organisation von Daten = **Datenstrukturen**\r\n\r\n(schrittweise) Modifikation von Daten zur Lösung eines Problems = **Algorithmen**\r\n\r\nEigenschaften eines Algorithmus (nach Donald Knuth):\r\n- Determinismus\r\n- Input ($\\# \\geq 0$)\r\n- Output ($\\# \\geq 1$)\r\n- Terminierung\r\n\r\n## Analyse von Algorithmen\r\n- Partielle / Totale Korrektheit\r\n- Komplexität (Speicherplatz, Rechenzeit)\r\n- Robustheit (bei inkorrekten Eingaben)\r\n\r\n### Partielle / Totale Korrektheit\r\n- Partielle Korrektheit: Liefert das richtige Ergebnis\r\n- Totale Korrektheit: Liefert das richtige Ergebnis und terminiert immer\r\n\r\n### Komplexität\r\n- Effizienz (Praxistauglichkeit)\r\n- Worst / Best / Average case\r\n- Wie viel länger dauert die Berechnung, wenn der Input verdoppelt wird?\r\n- Gibt es einen besseren Algorithmus? (Problem-Reduktion)\r\n\r\n### Effizienz\r\n- Problem $\\rightarrow$ Ressourcen (Wie viele Ressourcen brauche ich, um das Problem zu lösen?)\r\n- Ressourcen $\\rightarrow$ Problem (Welche Problem(klassen) kann ich mit meinen Ressourcen bearbeiten?)\r\n\r\n- Ressourcen-Typen:\r\n  - Rechenzeit\r\n  - Speicherplatz\r\n  - Energieverbrauch\r\n  - usw.\r\n\r\n## Ziele der Vorlesung\r\n- Grundlegende Konzepte für den Entwurf und die Analyse von Algorithmen\r\n- Effiziente Implementierung\r\n- Komplexitätsanalyse\r\n- Repertoire an Standardalgorithmen\r\n\r\n## Datenstrukturen\r\n- Lineare Strukturen\r\n  - Arrays, Listen, Stacks, Queues\r\n- Hierarchische Strukturen\r\n  - Bäume (Binär, Balanciert, B-, ...), Prioritätswarteschlangen\r\n- Graph Strukturen\r\n  - Gerichtet / ungerichtet, planare graphen\r\n\r\n![asdasdlawd dasd](/assets/images/09042022-Tabelle.png){width: 100%, max-width: 645px}\r\n","n":0.073}}},{"i":20,"$":{"0":{"v":"Organisatorisches","n":1},"1":{"v":"\n## Veranstaltungen\r\nVorlesungen:\r\n- Di: 10:30 - 12:00 Uhr (Audimax)\r\n- Do: 10:30 - 12:00 Uhr (Audimax)\r\n\r\nGlobalübung:\r\n- Fr: 10:30 - 12:00 Uhr (Audimax)\r\n\r\n## Übungsbetrieb\r\n- Übungsblattt `n` wird\r\n  - ausgegeben am Donnerstag in KW `i`\r\n  - abgegeben am Freitag in KW `i+1` (vor der Globalübung)\r\n\r\n```text\r\n75% der Übungspunkte = Bonus von 0,3\r\n```\r\n","n":0.146}}},{"i":21,"$":{"0":{"v":"Betriebssysteme und Systemsoftware","n":0.577},"1":{"v":"\n\r\n### Kapitel 0 - Einführung\r\n- [[§1 - Organisatorisches | 2-semester.bus.kapitel-0.einführung]]\r\n\r\n### Kapitel 1 - Betriebssysteme: Aufbau und Aufgaben\r\n- [[§1 - Aufbau von Rechnersystemen | 2-semester.bus.kapitel-1.aufbau]]","n":0.204}}},{"i":22,"$":{"0":{"v":"Kapitel 1","n":0.707}}},{"i":23,"$":{"0":{"v":"Aufbau von Rechnersystemen","n":0.577},"1":{"v":"\n\r\n## Einteilung\r\nEinteilung des gesamten Computers in vier Bereiche:\r\n- Computer Hardware; Ansammlung von *Betriebsmitteln*, welche die\r\nAusführung von Programmen ermöglichen\r\n- Betriebssystem; Verwaltung und *Koordination* der Hardware\r\n- System- und Anwendungsprogramme \r\n- Benutzer; können Menschen sein, aber auch andere Computer\r\n\r\n## Hardware\r\nDer sogenannte *Systembus* verbindet alle Geräte des Computers\r\n- CPU(s) zur Ausführung von Programmen\r\n- Gemeinsamer Speicher für Aufgaben der CPU und anderer Geräte\r\n- Controller zum Anschluss von I/O\r\n\r\n![Systembus](/assets/images/11042022-Systembus.png){width: 100%, max-width: 645px}\r\n\r\n## Rechnerarchitektur\r\n### Von-Neumann Rechner\r\n![Von-Neumann Rechner](/assets/images/11042022-VonNeumann.png){width: 100%, max-width: 645px}\r\n\r\n### Prozessor (CPU)\r\nVerfügt über *Register* zur Ausführung von Operationen\r\n- Datenregister, Adressregister, Spezialregister, ...\r\n\r\nZusätzlich verfügt eine CPU über *Caches* (L1/L2/L3)\r\n- Schnellerer Pufferspeicher\r\n- Zugriff auf Cache schneller als auf Hauptspeicher (RAM)\r\n- Kleiner = Schneller (Level 1 in der Regel am kleinsten, dafür aber auch am schnellsten)\r\n- Caches transparent für Betriebssystem - d.h. CPU kümmert sich um Management des Caches\r\n\r\n\r\n#### Speicherstrukturen\r\nAls Information interessant. Muss nicht für Klausur gelernt werden.\r\n\r\n| Hierarchie-Ebene          | Größe             | Zugriffszeit (ns)     |\r\n| ------------------------- | ----------------- | --------------------- |\r\n| 1: Register               | 8 - 64 Bit        | << 1                  |\r\n| 2: L1-Cache               | 16 - 64 KiB       | 1-2                   |\r\n| 3: L2-Cache               | 64 KiB - 4 MiB    | 2-4                   |\r\n| 4: L3-Cache               | 4 - 16 MiB        | 8-10                  |\r\n| 5: Hauptspeicher (RAM)    | >1 GiB            | ~60                   |\r\n| 6: Festplatte (SSD)       | >100 GiB          | ~5.000.000 (250.000)  |\r\n\r\n#### Prozessorkerne und Caches\r\n![Multiple Prozessorkerne](/assets/images/11042022-Kerne.png){width: 100%, max-width: 645px}\r\n\r\n\r\n#### Prozessor Parallelismus Architekturen\r\n- Pipelining\r\n  - Das Ausführen einer Instruktion lässt sich in Unterinstruktionen aufteilen\r\n    - z.B. Fetch, Decode, Execute, ...\r\n  - Dadurch lässt sich ein Instruktionsparallelismus implementieren\r\n  - Vorteil: Höherer Durchsatz\r\n  - Nachteil: Tlw. höhere Latenz\r\n\r\nBild einfügen\r\n\r\n- Superskalare Ausführung\r\n  - Wenn mehr als eine *Ausführungseinheit* existiert,\r\nkönnen auch mehrere Instruktionen in der selben\r\nPipelinestage parallel ausgeführt werden\r\n\r\nBild einfügen\r\n\r\n#### Hyperthreading\r\nAls Information interessant. Muss nicht für Klausur gelernt werden.\r\n\r\nHyperthreading, oder Hardware-seitiges Multithreading:\r\n- Mehrere Registersätze pro CPU, aber nur eine (oder weniger Rechenwerke)\r\n- Reduzierte Umschaltzeiten (-> Task-Wechsel)\r\n- Eine CPU-Core erscheint gegenüber dem Betriebssystem wie vier einzelne CPUs, aber mit reduzierter Leistung\r\n\r\n![Hyperthreading](/assets/images/11042022-Hyperthread.png){width: 100%, max-width: 645px}\r\n\r\nIn dem Bild ist klar erkennbar, dass jede \"Hyperthreading-CPU\" mehrere Register hat.\r\n\r\n### Zusammenspiel der Hardware-Komponenten\r\n- CPU führt Operationen aus\r\n- CPU und I/O Geräte werden *nebenläufig* ausgeführt\r\n  - Zur Ausführung einer Operation eines Gerätes wird die CPU benötigt\r\n    - Jeder Controller hat eigene Register und einen lokalen Buffer (Cache)\r\n    - Die CPU verschiebt Daten zwischen Hauptspeicher und Caches\r\n    - Nach Verschieben der Daten wird die Operation gestartet\r\n  - Heutzutage: *Direct Memory Access, DMA*\r\n    - Separater Controller zum Verschieben von Daten zwischen CPU und Geräten\r\n    - Entlastung der CPU\r\n\r\n### Wesentliche Komponenten des Rechnersystems:\r\n![Komponenten des Rechnersystems](/assets/images/11042022-StrukturRechnersystem.png){width: 100%, max-width: 645px}\r\n\r\n## Betriebssystem\r\n**Definition:** Ein Betriebssystem ist eine Ansammlung von Programmen, die die effiziente und kofortable Nutzung der Computer-Hardware ermöglichen\r\n- Platform zur Ausführung von Programmen auf einer Computer-Hardware\r\n- Effiziente Aufteilung der *Betriebsmittel* (CPU, Festplatten, ...) auf mehrere Benuztzer bzw. Benutzerprogramme\r\n\r\n### Betriebsmittel\r\nBetriebsmittel können sowohl Hardware- aber auch Softwareressourcen sein\r\n- Prozessoren, Prozesse, Threads\r\n- Speicher\r\n  - Hauptspeicher, Caches, virtueller Speicher\r\n- Dateisystem\r\n  - Verzeichnisse, Dateien\r\n- I/O Geräte\r\n  - Grafikkarte, Netzwerkkarte, Festplatte, Tastatur, ...\r\n\r\nBetriebsmittel können auf verschiedene Arten klassifiziert werden. Wichtig sind\r\nhier vor allem die folgenden Unterscheidungen:\r\n- Exklusive oder geteilte Nutzung?\r\n- Entziehbar oder nicht entziehbar?","n":0.045}}},{"i":24,"$":{"0":{"v":"Kapitel 0","n":0.707}}},{"i":25,"$":{"0":{"v":"Einführung","n":1},"1":{"v":"\n\r\n## Organisatorisches\r\n### Veranstaltungen\r\nVorlesungen:\r\n- Do: 12:30 - 14:00 (TEMP 1+2)\r\n- Fr: 12:30 - 14:00 (H02)\r\n\r\nGlobalübung:\r\n- Mo: 12:30 - 14:00 (TEMP 1+2) - evtl. Tausch mit VL\r\n\r\n### Übungsbetrieb\r\n- Übungsblatt wird immer Montags ausgegeben\r\n  - Insgesamt 8 Übungsblätter\r\n\r\n```text\r\nNotenbonus bis zu +0,7\r\n\r\nAb 50% der Punkte in Übungsblättern: KL. Zulassung\r\nAb 70%: +0,3 in KL.\r\nAb 90%: +0,7 in KL.\r\n```\r\n","n":0.137}}},{"i":26,"$":{"0":{"v":"1. Semester","n":0.707},"1":{"v":"\n### Achtung!\r\nDiese Seite befindet sich derzeit im Aufbau und steht aktuell noch nicht zur Verfügung. Schaue bitte später noch mal vorbei. \r\n","n":0.213}}},{"i":27,"$":{"0":{"v":"Technische Informatik","n":0.707}}},{"i":28,"$":{"0":{"v":"Programmierung","n":1}}},{"i":29,"$":{"0":{"v":"Diskrete Strukturen","n":0.707}}},{"i":30,"$":{"0":{"v":"Algebraische Strukturen","n":0.707}}},{"i":31,"$":{"0":{"v":"Gruppen","n":1},"1":{"v":"\n## Strukturen und Verknüpfungen\r\n**Definition:** Eine *Verknüpfung* auf einer Menge $M$ ist eine Abbildung\r\n$$\\begin{equation}\r\n    M \\times M \\rightarrow M\r\n\\end{equation}$$\r\nEine *algebraische Struktur* ist eine Menge mit ein oder mehreren Verknüpfungen.\r\n\r\n**Beispiele:**\r\n- \\- : $\\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}, (x,y) \\mapsto x - y$ ist eine Verknüpfung auf $\\mathbb{Z}$.\r\n- $\\land$ ist eine Verknüpfung auf $B = \\{0,1\\}$ (wenn wir 0 und 1 als Wahrheitswerte definieren, und $\\land$ durch die zugehörige Wahrheitstafel definiert ist).\r\n- $7 \\mathbb{Z} = \\{7a \\mid a \\in \\mathbb{Z}\\} = \\{\\ldots, -14, -7, 0, 7, 14, \\ldots\\}$\r\n\r\n**Schreibweise:**\r\nEs seien $M$ eine Menge, $\\bullet$ eine Verknüpfung auf $M, m \\in M$, und $A,B \\subseteq M$.\r\n- $m \\bullet A := \\{m \\bullet a \\mid a \\in A\\} \\subseteq M$\r\n- $A \\bullet m := \\{a \\bullet m \\mid a \\in A\\} \\subseteq M$\r\n- $A \\bullet B := \\{a \\bullet b \\mid a \\in A, b \\in B\\} \\subseteq M$\r\n\r\n## Monoide\r\n**Definition:** Es sei $M$ eine Menge mit einer Verknüpfung:\r\n$$\\begin{equation}\r\n    \\bullet : M \\times M \\rightarrow M, (x,y) \\mapsto x \\bullet y\r\n\\end{equation}$$\r\n^monoide_axiome\r\n\r\nWir nennen $(M, \\bullet)$ ein *Monoid*, wenn folgende Axiome gelten:\r\n1. $(x \\bullet y) \\bullet z = x \\bullet (y \\bullet z)$ für alle $x,y,z \\in M$\r\n2. Es existiert ein $e \\in M$ mit $e \\bullet x = x = x \\bullet e$ für alle $x \\in M$ <br>\r\nDas Monoid heißt *abelsch* oder *kommutativ*, wenn zusätzlich gilt:\r\n3. $x \\bullet y = y \\bullet x$ für alle $x,y \\in G$.\r\n\r\nMan nennt 1. das Assoziativgesetz und 3. das Kommutativgesetz.\r\n\r\n**Bemerkung:** Das Element $e$ in 2. ist eindeutig und wird das *neutrale Element* von $M$ genannt. \r\n\r\n**Beispiele:**\r\nEs sei $A$ eine beliebige Menge, $B := \\{0,1\\}$.\r\n- $(\\mathbb{N}, +)$ ist kein Monoid, da 2. nicht gilt. \r\n- $(\\mathbb{Z}, -)$ ist kein Monoid, da 1. nicht gilt.\r\n- $(\\mathbb{N}_0, +)$ ist ein abelsches Monoid mit neutralem Element 0.\r\n- $(\\mathbb{R}, \\cdot)$ ist ein abelsches Monoid mit neutralem Element 1.\r\n- $(B, \\land)$ ist ein abelsches Monoid mit neutralem Element 1.\r\n\r\n## Inverse und Einheiten\r\n**Definition:** Es seien $(M, \\bullet)$ ein Monoid mit neutralem Element $e$ und $a \\in M$.\r\n- Gibt es $b \\in M$ mit $a \\bullet b = e$, so heißt $a$ *rechtsinvertierbar* und $b$ *rechtsinvers* zu $a$ bzw. $b$ ein *Rechtsinverses* von $a$.\r\n- Gibt es $b \\in M$ mit $b \\bullet a = e$, so heißt $a$ *linksinvertierbar* und $b$ *linksinvers* zu $a$ bzw. $b$ ein *Linksinverses* von $a$.\r\n- Ist $a$ sowohl links- als auch rechtsinvertierbar, so heißt $a$ eine *Einheit*. \r\n- Gibt es $b \\in M$ mit $b \\bullet a = e = a \\bullet b$, so heißt $a$ *invertierbar* und $b$ *invers* zu $a$ bzw. $b$ ein *Inverses* von $a$.\r\n\r\n## Gruppe\r\n**Definition:** Ein Monoid $(G, \\bullet)$, in dem alle Elemente invertierbar sind, heißt *Gruppe*. D.h. in einer Gruppe gilt:\r\n\r\n([[M3 | #^monoide_axiome]]) Für alle $x \\in G$ existiert $x' \\in G$ mit $x \\bullet x' = e = x' \\bullet x$\r\n\r\n**Beispiele:**\r\n- $(\\mathbb{Z}, +)$ ist eine abelsche Gruppe.\r\n- $(\\mathbb{N}_0, +)$ ist keine Gruppe, da ([[M3 | #^monoide_axiome]]) nicht gilt. \r\n- $(\\mathbb{R}, \\cdot)$ ist keine Gruppe, da ([[M3 | #^monoide_axiome]]) nicht gilt.\r\n- $(\\mathbb{R} \\backslash \\{0\\}, \\cdot)$ und $(R_{>0}, \\cdot)$ sind abelsche Gruppen. \r\n\r\n## Untergruppen ","n":0.045}}},{"i":32,"$":{"0":{"v":"Analysis für Informatiker","n":0.577}}}]}
