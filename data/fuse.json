{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Tags","n":1}}},{"i":2,"$":{"0":{"v":"My","n":1}}},{"i":3,"$":{"0":{"v":"Example","n":1}}},{"i":4,"$":{"0":{"v":"2. Semester","n":0.707}}},{"i":5,"$":{"0":{"v":"Lineare Algebra","n":0.707}}},{"i":6,"$":{"0":{"v":"Fosap","n":1}}},{"i":7,"$":{"0":{"v":"Einführung","n":1},"1":{"v":"\n## Einfürung\r\n**Syntax:** Schreibweise eines formalen Systems\r\n\r\n**Semantik:** klar definierte Bedeutung eines formalen\r\nSystems\r\n\r\n- Automaten\r\n- Grammatiken (regulär; kontextfrei)\r\n- Nebenläufige Systeme (...)","n":0.236}}},{"i":8,"$":{"0":{"v":"Datenstrukturen und Algorithmen","n":0.577},"1":{"v":"\n### Kapitel 0 - Einführung\n- [[§1 - Organisatorisches|2-semester.dsal.kapitel-0.organisatorisches]]\n- [[§2 - Überblick|2-semester.dsal.kapitel-0.überblick]]\n\n### Kapitel 1 - Datenstrukturen\n- [[§1 - Abstrakte Datentypen | 2-semester.dsal.kapitel-1.datenstrukturen.abstrakte-datentypen]]\n- [[§2 - Lineare Strukturen | 2-semester.dsal.kapitel-1.datenstrukturen.lineare-strukturen]]\n","n":0.192}}},{"i":9,"$":{"0":{"v":"Kapitel 1 - Datenstrukturen","n":0.5}}},{"i":10,"$":{"0":{"v":"Lineare Strukturen","n":0.707},"1":{"v":"\n- Sequenz $\\{x_1,\\ldots,x_n\\}$ von beliebigen Datenobjekten $x_i$\n- Typische Operationen (Beispiele)\n  - Füge $y$ am Anfang / am Ende / hinter $x_i$ ein\n  - Ersetze $x_i$ durch $y$\n  - Entferne $x_i$\n\n## Listen\n- $L = \\{x_1, \\ldots, x_n\\}$\n- Zugriff auf beliebige Elemente $x_i$\n  - Per Index (random access)\n    - Get(i)\n  - Per Marker (sequential access)\n    - GetFirst()\n    - GetNext()\n    - GetPrevious()\n\nRandom access:\n- Typischerweise implementierung durch Arrays L[]\n- Get(i) = L[i]\n- Nachteile:\n  - Elemente löschen erzeugt Lücken oder alle Elemente mit höherem Index müssen verschoben werden (garbage collection)\n  - Statische Obergrenze für Listenlänge\n\nSequential Access:\n- Implementierung durch Pointer oder Container\n- Marker zeigt auf aktuelle Position\n- Nachteil: Elementzugriff erfordert lineare Suche\n  - kann meistens durch \"for each\" vermieden werden\n- Vorteil: Beliebiges Erweitern und Löschen\n\nSpezifikation:\n- Wertebereich: $L = \\{\\} \\cup W \\cup W^2 \\cup W^3 \\cup \\ldots$\n- Create: $\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Get: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow W$\n- Next: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Insert: $W \\times L \\rightarrow L$\n- Delete: $L \\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Reset: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Empty: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow Bool$\n- IsLast: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow Bool$\n\n<u>Achtung:</u> der Marker beschreibt einen *Zustand*, was sich mit *funktionalen* Axiomen schlecht formulieren lässt.\n\n<u>Standard-Trick:</u> Führe ein zusätzliches Prädikat _Insert*_ ein, das aber keine eigene Listen-Funkttion darstellt:\n\n```text\nInsert(x,Insert(y,Insert(z,Create())))\n    = {X,y,z}\n\nInsert*(x,Insert(y,Insert(z,Create())))\n    = {x,Y,z}\n\nInsert*(x,Insert*(y,Insert(z,Create())))\n    = {x,y,Z}\n```\n\n","n":0.07}}},{"i":11,"$":{"0":{"v":"Abstrakte Datentypen","n":0.707},"1":{"v":"\nAbstrakte Datentypen spezifizieren *Form und Funktionalität* der zu verarbeitenden Daten.\n\nBeispiel (Addition zweier Zeiten):\n- Datenobjekte, Datenfelder\n  - Zeit: `hh:mm:ss`\n- Funktionen:\n  - Add: `Zeit` $\\times$ `Zeit` $\\rightarrow$ `Zeit`\n- Axiome:\n  - `Add` $([h_1, m_1, s_1], [h_2, m_2, s_2]) =$ <br>\n  $[(h_1 + h_2 + (m_1 + m_2 + (s_1 + s_2) / 60) / 60) \\: \\% \\: 24$, <br> $(m_1 + m_2 + (s_1 + s_2) / 60) \\: \\% \\: 60$, <br> $(s_1+s_2)) \\: \\% \\: 60]$\n\n## Datentypen\n- Aufzählungstypen (bool, enum)\n  - 0-Dimensional\n  - Endlicher Wertebereich (vollständige Spezifikation durch Tabellen möglich)\n  - [[Beispiel | 2-semester.dsal.kapitel-1.datenstrukturen.abstrakte-datentypen.beispiele#aufzählungstypen-bool]]\n- Skalare Typen (char, int, float, ...)\n  - 1-Dimensional\n  - [[Beispiel | 2-semester.dsal.kapitel-1.datenstrukturen.abstrakte-datentypen.beispiele#skalare-typen-integer]]\n- Zusammengesetzte Typen (struct, class)\n  - n-Dimensional\n  - Endliche / Feste zusammengesetzte Typen\n    - k-dim. Vektoren (Tupel)\n    - Addressen-Eintrag\n- Lineare Strukturen (list, queue, stack)\n  - [1:1] Beziehung\n  - [[Beispiel | 2-semester.dsal.kapitel-1.datenstrukturen.abstrakte-datentypen.beispiele#lineare-strukturen]]\n- Bäume\n  - [1:n] Beziehung\n  - [[Beispiel | 2-semester.dsal.kapitel-1.datenstrukturen.abstrakte-datentypen.beispiele#baumstrukturen]]\n- Graphen - n-m Strukturen\n  - [n:m] Beziehung\n  - Beliebige *topologische* Struktur\n  - Nachbarschafsbeziehungen zwischen Knoten\n  - Wichtige Spezialfälle:\n    - Planare Graphen\n    - Gerichtete Graphen\n    - Zyklenfreie Graphen\n\n## Warum abstrakt?\n- Keine Festlegung, wie die jeweiligen Funktionen *implementiert* werden (\"Transparenz\")\n- Axiome beschreiben *statische* Beziehungen (\"$=$\" vs. \"$:=$\")","n":0.073}}},{"i":12,"$":{"0":{"v":"Beispiele","n":1},"1":{"v":"\n## Aufzählungstypen (Bool)\r\n0-Dimensional\r\n\r\n- Wertebereich: $\\{true, false\\}$\r\n- $\\neg : bool \\times bool \\rightarrow bool$\r\n- $\\land : bool \\times bool \\rightarrow bool$\r\n- $\\lor : bool \\times bool \\rightarrow bool$\r\n\r\n$\\neg \\: true = false, \\neg \\: false = true$\r\n\r\n| $\\land$ | True | False |\r\n| ------- | ---- | ----- |\r\n| **True**    | True | False |\r\n| **False**   | False| False |\r\n<br>\r\n\r\n| $\\land$ | True | False |\r\n| ------- | ---- | ----- |\r\n| **True**    | True | True  |\r\n| **False**   | True| False  |\r\n\r\n## Skalare Typen (Integer)\r\n1-Dimensional\r\n\r\n- Wertebereich: $\\mathbb{Z} = \\mathbb{N}_{+} \\cup \\{0\\} \\cup -\\mathbb{N}_{+}$\r\n- $+ : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $- : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $- : \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $\\times : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n- $\\div : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\r\n\r\nAxiome:\r\n- $+(0,b) = b$\r\n- $+(a+1,b) = +(a,b)+1 \\:\\:\\:\\:$     (count down to 0)\r\n- $+(a-1,b) = +(a,b)-1 \\:\\:\\:\\:$     (count up to 0)\r\n<br><br>\r\n- $-(b,b) = 0$\r\n- $-(a+1,b) = -(a,b)+1$\r\n- $-(a-1,b) = -(a,b)-1$\r\n<br><br>\r\n- $-(b) = -(0,b)$\r\n<br><br>\r\n- $\\times(0,b) = 0$\r\n- $\\times(a+1,b) = +(\\times(a,b),b)$\r\n- $\\times(a-1,b) = -(\\times(a,b),b)$\r\n<br><br>\r\n- $\\div(a,0) = \\text{ERR}$\r\n- $\\div(a,b) = 0$ if $|a| < |b|$\r\n- $\\div(a+b,b) = \\div(a,b)+1$\r\n- $\\div(a-b,b) = \\div(a,b)-1$\r\n\r\n## Lineare Strukturen\r\n- Beliebige Sequenz von Basisobjekten (skalare / zusammengesetzte Typen) mit variabler Länge\r\n  - Arrays\r\n  - Listen (einfch / doppelt verkettet)\r\n  - Queue (FIFO)\r\n  - Stack (LIFO)\r\n- Unterscheiden sich im Wesentlichen in der Zugriffsfunktionalität\r\n\r\n### Beispiel (Sequenz):\r\n- Wertebereich: $W = \\{\\} \\cup N \\cup N^2 \\cup N^3 \\cup \\ldots$\r\n  - $\\neq 2^N$\r\n- Create: $\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow W$\r\n- Append: $N \\times W \\rightarrow W$\r\n- Remove: $N \\times W \\rightarrow W$\r\n\r\nAxiome:\r\n- Create() = $\\{\\}$\r\n- Append($X,\\{y_1, \\ldots, y_n\\}$) = $\\{y_1,\\ldots,y_n,X\\}$\r\n  - Append(z,Append(y,Append(x,Create()))) = $\\{x,y,z\\}$\r\n- Remove(x,Create()) = Create()\r\n- Remove(x,Append(x,z)) = z\r\n- Remove(x,Append(y,z)) = Append(y,Remove(x,z)) *if x $\\neq$ y*\r\n\r\n## Baumstrukturen\r\n- Hierarchische Strukturen\r\n- Mutter / Kind-Beziehung [1:n]\r\n- Keine Zyklen\r\n- Eindeuttige Vorfahren\r\n\r\nAxiome:\r\n- Insert(x,Create()) = Node(Create(),x,Create())\r\n- Insert(x,Node(left,x,right)) = Node(left,x,right)\r\n- Insert(x,Node(left,y,right)) = <br>\r\n    if x < y: Node(Insert(x,left), y, right) <br>\r\n    if x > y: Node(left,y,Insert(x,right))\n","n":0.057}}},{"i":13,"$":{"0":{"v":"Kapitel 0 - Einführung","n":0.5}}},{"i":14,"$":{"0":{"v":"Überblick","n":1},"1":{"v":"\n## Positionsbestimmung\n\nInformatik = Wissenschaft von der *algorithmischen* Problemlösung\n- Gegeben: Problem(klasse)\n- Gesucht: Lösungsprozedur ((automatisierbare) Lösung aus elementaren Schritten)\n\n## Definitionen\n\nRepräsentation / Organisation von Daten = **Datenstrukturen**\n\n(schrittweise) Modifikation von Daten zur Lösung eines Problems = **Algorithmen**\n\nEigenschaften eines Algorithmus (nach Donald Knuth):\n- Determinismus\n- Input ($\\# \\geq 0$)\n- Output ($\\# \\geq 1$)\n- Terminierung\n\n## Analyse von Algorithmen\n- Partielle / Totale Korrektheit\n- Komplexität (Speicherplatz, Rechenzeit)\n- Robustheit (bei inkorrekten Eingaben)\n\n### Partielle / Totale Korrektheit:\n- Partielle Korrektheit: Liefert das richtige Ergebnis\n- Totale Korrektheit: Liefert das richtige Ergebnis und terminiert immer\n\n### Komplexität:\n- Effizienz (Praxistauglichkeit)\n- Worst / Best / Average case\n- Wie viel länger dauert die Berechnung, wenn der Input verdoppelt wird?\n- Gibt es einen besseren Algorithmus? (Problem-Reduktion)\n\n### Effizienz:\n- Problem $\\rightarrow$ Ressourcen (Wie viele Ressourcen brauche ich, um das Problem zu lösen?)\n- Ressourcen $\\rightarrow$ Problem (Welche Problem(klassen) kann ich mit meinen Ressourcen bearbeiten?)\n\n- Ressourcen-Typen:\n  - Rechenzeit\n  - Speicherplatz\n  - Energieverbrauch\n  - usw.\n\n## Ziele der Vorlesung\n- Grundlegende Konzepte für den Entwurf und die Analyse von Algorithmen\n- Effiziente Implementierung\n- Komplexitätsanalyse\n- Repertoire an Standardalgorithmen\n\n## Datenstrukturen\n- Lineare Strukturen\n  - Arrays, Listen, Stacks, Queues\n- Hierarchische Strukturen\n  - Bäume (Binär, Balanciert, B-, ...), Prioritätswarteschlangen\n- Graph Strukturen\n  - Gerichtet / ungerichtet, planare graphen\n\n![asdasdlawd dasd](/assets/images/09042022-Tabelle.png){width: 100%, max-width: 645px}\n","n":0.073}}},{"i":15,"$":{"0":{"v":"Organisatorisches","n":1},"1":{"v":"\n## Organisatorisches\r\n### Veranstaltungen\r\nVorlesungen:\r\n- Di: 10:30 - 12:00 Uhr (Audimax)\r\n- Do: 10:30 - 12:00 Uhr (Audimax)\r\n\r\nGlobalübung:\r\n- Fr: 10:30 - 12:00 Uhr (Audimax)\r\n\r\n### Übungsbetrieb\r\n- Übungsblattt `n` wird\r\n  - ausgegeben am Donnerstag in KW `i`\r\n  - abgegeben am Freitag in KW `i+1` (vor der Globalübung)\r\n\r\n```text\r\n75% der Übungspunkte = Bonus von 0,3\r\n```\r\n","n":0.144}}},{"i":16,"$":{"0":{"v":"Betriebssysteme und Systemsoftware","n":0.577},"1":{"v":"\n\r\n### Kapitel 0 - Einführung\r\n- [[§1 Organisatorisches | 2-semester.bus.einführung]]","n":0.333}}},{"i":17,"$":{"0":{"v":"Einführung","n":1},"1":{"v":"\n## Organisatorisches\n### Veranstaltungen\nVorlesungen:\n- Do: 12:30 - 14:00 (TEMP 1+2)\n- Fr: 12:30 - 14:00 (H02)\n\nGlobalübung:\n- Mo: 12:30 - 14:00 (TEMP 1+2) - evtl. Tausch mit VL\n\n### Übungsbetrieb\n- Übungsblatt wird immer Montags ausgegeben\n  - Insgesamt 8 Übungsblätter\n\n```text\nNotenbonus bis zu +0,7\n\nAb 50% der Punkte in Übungsblättern: KL. Zulassung\nAb 70%: +0,3 in KL.\nAb 90%: +0,7 in KL.\n```","n":0.137}}},{"i":18,"$":{"0":{"v":"1. Semester","n":0.707},"1":{"v":"\n### Achtung!\r\nDiese Seite befindet sich derzeit im Aufbau und steht aktuell noch nicht zur Verfügung. Schaue bitte später noch mal vorbei. \r\n","n":0.213}}},{"i":19,"$":{"0":{"v":"Technische Informatik","n":0.707}}},{"i":20,"$":{"0":{"v":"Programmierung","n":1}}},{"i":21,"$":{"0":{"v":"Diskrete Strukturen","n":0.707}}},{"i":22,"$":{"0":{"v":"Algebraische Strukturen","n":0.707}}},{"i":23,"$":{"0":{"v":"Gruppen","n":1},"1":{"v":"\n## Strukturen und Verknüpfungen\r\n**Definition:** Eine *Verknüpfung* auf einer Menge $M$ ist eine Abbildung\r\n$$\\begin{equation}\r\n    M \\times M \\rightarrow M\r\n\\end{equation}$$\r\nEine *algebraische Struktur* ist eine Menge mit ein oder mehreren Verknüpfungen.\r\n\r\n**Beispiele:**\r\n- \\- : $\\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}, (x,y) \\mapsto x - y$ ist eine Verknüpfung auf $\\mathbb{Z}$.\r\n- $\\land$ ist eine Verknüpfung auf $B = \\{0,1\\}$ (wenn wir 0 und 1 als Wahrheitswerte definieren, und $\\land$ durch die zugehörige Wahrheitstafel definiert ist).\r\n- $7 \\mathbb{Z} = \\{7a \\mid a \\in \\mathbb{Z}\\} = \\{\\ldots, -14, -7, 0, 7, 14, \\ldots\\}$\r\n\r\n**Schreibweise:**\r\nEs seien $M$ eine Menge, $\\bullet$ eine Verknüpfung auf $M, m \\in M$, und $A,B \\subseteq M$.\r\n- $m \\bullet A := \\{m \\bullet a \\mid a \\in A\\} \\subseteq M$\r\n- $A \\bullet m := \\{a \\bullet m \\mid a \\in A\\} \\subseteq M$\r\n- $A \\bullet B := \\{a \\bullet b \\mid a \\in A, b \\in B\\} \\subseteq M$\r\n\r\n## Monoide\r\n**Definition:** Es sei $M$ eine Menge mit einer Verknüpfung:\r\n$$\\begin{equation}\r\n    \\bullet : M \\times M \\rightarrow M, (x,y) \\mapsto x \\bullet y\r\n\\end{equation}$$\r\n^monoide_axiome\r\n\r\nWir nennen $(M, \\bullet)$ ein *Monoid*, wenn folgende Axiome gelten:\r\n1. $(x \\bullet y) \\bullet z = x \\bullet (y \\bullet z)$ für alle $x,y,z \\in M$\r\n2. Es existiert ein $e \\in M$ mit $e \\bullet x = x = x \\bullet e$ für alle $x \\in M$ <br>\r\nDas Monoid heißt *abelsch* oder *kommutativ*, wenn zusätzlich gilt:\r\n3. $x \\bullet y = y \\bullet x$ für alle $x,y \\in G$.\r\n\r\nMan nennt 1. das Assoziativgesetz und 3. das Kommutativgesetz.\r\n\r\n**Bemerkung:** Das Element $e$ in 2. ist eindeutig und wird das *neutrale Element* von $M$ genannt. \r\n\r\n**Beispiele:**\r\nEs sei $A$ eine beliebige Menge, $B := \\{0,1\\}$.\r\n- $(\\mathbb{N}, +)$ ist kein Monoid, da 2. nicht gilt. \r\n- $(\\mathbb{Z}, -)$ ist kein Monoid, da 1. nicht gilt.\r\n- $(\\mathbb{N}_0, +)$ ist ein abelsches Monoid mit neutralem Element 0.\r\n- $(\\mathbb{R}, \\cdot)$ ist ein abelsches Monoid mit neutralem Element 1.\r\n- $(B, \\land)$ ist ein abelsches Monoid mit neutralem Element 1.\r\n\r\n## Inverse und Einheiten\r\n**Definition:** Es seien $(M, \\bullet)$ ein Monoid mit neutralem Element $e$ und $a \\in M$.\r\n- Gibt es $b \\in M$ mit $a \\bullet b = e$, so heißt $a$ *rechtsinvertierbar* und $b$ *rechtsinvers* zu $a$ bzw. $b$ ein *Rechtsinverses* von $a$.\r\n- Gibt es $b \\in M$ mit $b \\bullet a = e$, so heißt $a$ *linksinvertierbar* und $b$ *linksinvers* zu $a$ bzw. $b$ ein *Linksinverses* von $a$.\r\n- Ist $a$ sowohl links- als auch rechtsinvertierbar, so heißt $a$ eine *Einheit*. \r\n- Gibt es $b \\in M$ mit $b \\bullet a = e = a \\bullet b$, so heißt $a$ *invertierbar* und $b$ *invers* zu $a$ bzw. $b$ ein *Inverses* von $a$.\r\n\r\n## Gruppe\r\n**Definition:** Ein Monoid $(G, \\bullet)$, in dem alle Elemente invertierbar sind, heißt *Gruppe*. D.h. in einer Gruppe gilt:\r\n\r\n([[M3 | #^monoide_axiome]]) Für alle $x \\in G$ existiert $x' \\in G$ mit $x \\bullet x' = e = x' \\bullet x$\r\n\r\n**Beispiele:**\r\n- $(\\mathbb{Z}, +)$ ist eine abelsche Gruppe.\r\n- $(\\mathbb{N}_0, +)$ ist keine Gruppe, da ([[M3 | #^monoide_axiome]]) nicht gilt. \r\n- $(\\mathbb{R}, \\cdot)$ ist keine Gruppe, da ([[M3 | #^monoide_axiome]]) nicht gilt.\r\n- $(\\mathbb{R} \\backslash \\{0\\}, \\cdot)$ und $(R_{>0}, \\cdot)$ sind abelsche Gruppen. \r\n\r\n## Untergruppen ","n":0.045}}},{"i":24,"$":{"0":{"v":"Analysis für Informatiker","n":0.577}}}]}
