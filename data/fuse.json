{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Tags","n":1}}},{"i":2,"$":{"0":{"v":"My","n":1}}},{"i":3,"$":{"0":{"v":"Example","n":1}}},{"i":4,"$":{"0":{"v":"2. Semester","n":0.707}}},{"i":5,"$":{"0":{"v":"Lineare Algebra","n":0.707}}},{"i":6,"$":{"0":{"v":"Fosap","n":1}}},{"i":7,"$":{"0":{"v":"Einführung","n":1},"1":{"v":"## Einfürung\n**Syntax:** Schreibweise eines formalen Systems\n\n**Semantik:** klar definierte Bedeutung eines formalen\nSystems\n\n- Automaten\n- Grammatiken (regulär; kontextfrei)\n- Nebenläufige Systeme (...)","n":0.236}}},{"i":8,"$":{"0":{"v":"Datenstrukturen und Algorithmen","n":0.577},"1":{"v":"\n### Kapitel 0 - Einführung\n- [[§1 - Organisatorisches | 2-semester.dsal.einführung#organisatorisches]]\n- [[§2 - Überblick | 2-semester.dsal.einführung#überblick]]\n\n### Kapitel 1 - Datenstrukturen\n- [[§1 - Abstrakte Datentypen | 2-semester.dsal.datenstrukturen#abstrakte-datentypen]]\n- [[§2 - Lineare Strukturen | 2-semester.dsal.datenstrukturen#lineare-strukturen]]","n":0.18}}},{"i":9,"$":{"0":{"v":"Einführung","n":1},"1":{"v":"## Organisatorisches\n### Veranstaltungen\nVorlesungen:\n- Di: 10:30 - 12:00 Uhr (Audimax)\n- Do: 10:30 - 12:00 Uhr (Audimax)\n\nGlobalübung:\n- Fr: 10:30 - 12:00 Uhr (Audimax)\n\n### Übungsbetrieb\n- Übungsblattt `n` wird\n  - ausgegeben am Donnerstag in KW `i`\n  - abgegeben am Freitag in KW `i+1` (vor der Globalübung)\n\n```text\n75% der Übungspunkte = Bonus von 0,3\n```\n\n## Überblick\n### Positionsbestimmung\n\nInformatik = Wissenschaft von der *algorithmischen* Problemlösung\n- Gegeben: Problem(klasse)\n- Gesucht: Lösungsprozedur ((automatisierbare) Lösung aus elementaren Schritten)\n\n### Definitionen\n\nRepräsentation / Organisation von Daten = **Datenstrukturen**\n\n(schrittweise) Modifikation von Daten zur Lösung eines Problems = **Algorithmen**\n\nEigenschaften eines Algorithmus (nach Donald Knuth):\n- Determinismus\n- Input ($\\# \\geq 0$)\n- Output ($\\# \\geq 1$)\n- Terminierung\n\n### Analyse von Algorithmen\n- Partielle / Totale Korrektheit\n- Komplexität (Speicherplatz, Rechenzeit)\n- Robustheit (bei inkorrekten Eingaben)\n\nPartielle / Totale Korrektheit:\n- Partielle Korrektheit: Liefert das richtige Ergebnis\n- Totale Korrektheit: Liefert das richtige Ergebnis und terminiert immer\n\nKomplexität:\n- Effizienz (Praxistauglichkeit)\n- Worst / Best / Average case\n- Wie viel länger dauert die Berechnung, wenn der Input verdoppelt wird?\n- Gibt es einen besseren Algorithmus? (Problem-Reduktion)\n\nEffizienz:\n- Problem $\\rightarrow$ Ressourcen (Wie viele Ressourcen brauche ich, um das Problem zu lösen?)\n- Ressourcen $\\rightarrow$ Problem (Welche Problem(klassen) kann ich mit meinen Ressourcen bearbeiten?)\n\n- Ressourcen-Typen:\n  - Rechenzeit\n  - Speicherplatz\n  - Energieverbrauch\n  - usw.\n\n### Ziele der Vorlesung\n- Grundlegende Konzepte für den Entwurf und die Analyse von Algorithmen\n- Effiziente Implementierung\n- Komplexitätsanalyse\n- Repertoire an Standardalgorithmen\n\n### Datenstrukturen\n- Lineare Strukturen\n  - Arrays, Listen, Stacks, Queues\n- Hierarchische Strukturen\n  - Bäume (Binär, Balanciert, B-, ...), Prioritätswarteschlangen\n- Graph Strukturen\n  - Gerichtet / ungerichtet, planare graphen\n\n![asdasdlawd dasd](/assets/images/09042022-Tabelle.png){width: 100%, max-width: 645px}","n":0.065}}},{"i":10,"$":{"0":{"v":"Datenstrukturen","n":1},"1":{"v":"\n## Abstrakte Datentypen\nAbstrakte Datentypen spezifizieren *Form und Funktionalität* der zu verarbeitenden Daten.\n\nBeispiel (Addition zweier Zeiten):\n- Datenobjekte, Datenfelder\n  - Zeit: `hh:mm:ss`\n- Funktionen:\n  - Add: `Zeit` $\\times$ `Zeit` $\\rightarrow$ `Zeit`\n- Axiome:\n  - `Add` $([h_1, m_1, s_1], [h_2, m_2, s_2]) =$ <br>\n  $[(h_1 + h_2 + (m_1 + m_2 + (s_1 + s_2) / 60) / 60) \\: \\% \\: 24$, <br> $(m_1 + m_2 + (s_1 + s_2) / 60) \\: \\% \\: 60$, <br> $(s_1+s_2)) \\: \\% \\: 60]$\n\n### Datentypen\n- Aufzählungstypen (bool, enum)\n  - 0-Dimensional\n  - Endlicher Wertebereich (vollständige Spezifikation durch Tabellen möglich)\n  - [[Beispiel | 2-semester.dsal.datenstrukturen.beispiele#aufzählungstypen-bool]]\n- Skalare Typen (char, int, float, ...)\n  - 1-Dimensional\n  - [[Beispiel | 2-semester.dsal.datenstrukturen.beispiele#skalare-typen-integer]]\n- Zusammengesetzte Typen (struct, class)\n  - n-Dimensional\n  - Endliche / Feste zusammengesetzte Typen\n    - k-dim. Vektoren (Tupel)\n    - Addressen-Eintrag\n- Lineare Strukturen (list, queue, stack)\n  - [1:1] Beziehung\n  - [[Beispiel | 2-semester.dsal.datenstrukturen.beispiele#lineare-strukturen]]\n- Bäume\n  - [1:n] Beziehung\n  - [[Beispiel | 2-semester.dsal.datenstrukturen.beispiele#baumstrukturen]]\n- Graphen - n-m Strukturen\n  - [n:m] Beziehung\n  - Beliebige *topologische* Struktur\n  - Nachbarschafsbeziehungen zwischen Knoten\n  - Wichtige Spezialfälle:\n    - Planare Graphen\n    - Gerichtete Graphen\n    - Zyklenfreie Graphen\n\n### Warum abstrakt?\n- Keine Festlegung, wie die jeweiligen Funktionen *implementiert* werden (\"Transparenz\")\n- Axiome beschreiben *statische* Beziehungen (\"$=$\" vs. \"$:=$\")\n\n## Lineare Strukturen\n- Sequenz $\\{x_1,\\ldots,x_n\\}$ von beliebigen Datenobjekten $x_i$\n- Typische Operationen (Beispiele)\n  - Füge $y$ am Anfang / am Ende / hinter $x_i$ ein\n  - Ersetze $x_i$ durch $y$\n  - Entferne $x_i$\n\n### Listen\n- $L = \\{x_1, \\ldots, x_n\\}$\n- Zugriff auf beliebige Elemente $x_i$\n  - Per Index (random access)\n    - Get(i)\n  - Per Marker (sequential access)\n    - GetFirst()\n    - GetNext()\n    - GetPrevious()\n\nRandom access:\n- Typischerweise implementierung durch Arrays L[]\n- Get(i) = L[i]\n- Nachteile:\n  - Elemente löschen erzeugt Lücken oder alle Elemente mit höherem Index müssen verschoben werden (garbage collection)\n  - Statische Obergrenze für Listenlänge\n\nSequential Access:\n- Implementierung durch Pointer oder Container\n- Marker zeigt auf aktuelle Position\n- Nachteil: Elementzugriff erfordert lineare Suche\n  - kann meistens durch \"for each\" vermieden werden\n- Vorteil: Beliebiges Erweitern und Löschen\n\nSpezifikation:\n- Wertebereich: $L = \\{\\} \\cup W \\cup W^2 \\cup W^3 \\cup \\ldots$\n- Create: $\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Get: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow W$\n- Next: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Insert: $W \\times L \\rightarrow L$\n- Delete: $L \\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Reset: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow L$\n- Empty: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow Bool$\n- IsLast: $L \\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow Bool$\n\n<u>Achtung:</u> der Marker beschreibt einen *Zustand*, was sich mit *funktionalen* Axiomen schlecht formulieren lässt.\n\n<u>Standard-Trick:</u> Führe ein zusätzliches Prädikat _Insert*_ ein, das aber keine eigene Listen-Funkttion darstellt:\n\n```text\nInsert(x,Insert(y,Insert(z,Create())))\n    = {X,y,z}\n\nInsert*(x,Insert(y,Insert(z,Create())))\n    = {x,Y,z}\n\nInsert*(x,Insert*(y,Insert(z,Create())))\n    = {x,y,Z}\n```","n":0.05}}},{"i":11,"$":{"0":{"v":"Datenstrukturen Beispiele","n":0.707},"1":{"v":"\n## Aufzählungstypen (Bool)\n0-Dimensional\n\n- Wertebereich: $\\{true, false\\}$\n- $\\neg : bool \\times bool \\rightarrow bool$\n- $\\land : bool \\times bool \\rightarrow bool$\n- $\\lor : bool \\times bool \\rightarrow bool$\n\n$\\neg \\: true = false, \\neg \\: false = true$\n\n| $\\land$ | True | False |\n| ------- | ---- | ----- |\n| **True**    | True | False |\n| **False**   | False| False |\n<br>\n\n| $\\land$ | True | False |\n| ------- | ---- | ----- |\n| **True**    | True | True  |\n| **False**   | True| False  |\n\n## Skalare Typen (Integer)\n1-Dimensional\n\n- Wertebereich: $\\mathbb{Z} = \\mathbb{N}_{+} \\cup \\{0\\} \\cup -\\mathbb{N}_{+}$\n- $+ : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\n- $- : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\n- $- : \\mathbb{Z} \\rightarrow \\mathbb{Z}$\n- $\\times : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\n- $\\div : \\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}$\n\nAxiome:\n- $+(0,b) = b$\n- $+(a+1,b) = +(a,b)+1 \\:\\:\\:\\:$     (count down to 0)\n- $+(a-1,b) = +(a,b)-1 \\:\\:\\:\\:$     (count up to 0)\n<br><br>\n- $-(b,b) = 0$\n- $-(a+1,b) = -(a,b)+1$\n- $-(a-1,b) = -(a,b)-1$\n<br><br>\n- $-(b) = -(0,b)$\n<br><br>\n- $\\times(0,b) = 0$\n- $\\times(a+1,b) = +(\\times(a,b),b)$\n- $\\times(a-1,b) = -(\\times(a,b),b)$\n<br><br>\n- $\\div(a,0) = \\text{ERR}$\n- $\\div(a,b) = 0$ if $|a| < |b|$\n- $\\div(a+b,b) = \\div(a,b)+1$\n- $\\div(a-b,b) = \\div(a,b)-1$\n\n## Lineare Strukturen\n- Beliebige Sequenz von Basisobjekten (skalare / zusammengesetzte Typen) mit variabler Länge\n  - Arrays\n  - Listen (einfch / doppelt verkettet)\n  - Queue (FIFO)\n  - Stack (LIFO)\n- Unterscheiden sich im Wesentlichen in der Zugriffsfunktionalität\n\n### Beispiel (Sequenz):\n- Wertebereich: $W = \\{\\} \\cup N \\cup N^2 \\cup N^3 \\cup \\ldots$\n  - $\\neq 2^N$\n- Create: $\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\:\\: \\rightarrow W$\n- Append: $N \\times W \\rightarrow W$\n- Remove: $N \\times W \\rightarrow W$\n\nAxiome:\n- Create() = $\\{\\}$\n- Append($X,\\{y_1, \\ldots, y_n\\}$) = $\\{y_1,\\ldots,y_n,X\\}$\n  - Append(z,Append(y,Append(x,Create()))) = $\\{x,y,z\\}$\n- Remove(x,Create()) = Create()\n- Remove(x,Append(x,z)) = z\n- Remove(x,Append(y,z)) = Append(y,Remove(x,z)) *if x $\\neq$ y*\n\n## Baumstrukturen\n- Hierarchische Strukturen\n- Mutter / Kind-Beziehung [1:n]\n- Keine Zyklen\n- Eindeuttige Vorfahren\n\nAxiome:\n- Insert(x,Create()) = Node(Create(),x,Create())\n- Insert(x,Node(left,x,right)) = Node(left,x,right)\n- Insert(x,Node(left,y,right)) = <br>\n    if x < y: Node(Insert(x,left), y, right) <br>\n    if x > y: Node(left,y,Insert(x,right))\n\n","n":0.057}}},{"i":12,"$":{"0":{"v":"Betriebssysteme und Systemsoftware","n":0.577},"1":{"v":"\n## Einleitung\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\n\n### Subsection\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\n\n##### Subsubsection\n```java\npublic static void main(String[] args)\n{\n    System.out.println(\"Hello World\");\n}\n```","n":0.069}}},{"i":13,"$":{"0":{"v":"1. Semester","n":0.707},"1":{"v":"### Achtung!\nDiese Seite befindet sich derzeit im Aufbau und steht aktuell noch nicht zur Verfügung. Schaue bitte später noch mal vorbei. \n","n":0.213}}},{"i":14,"$":{"0":{"v":"Technische Informatik","n":0.707}}},{"i":15,"$":{"0":{"v":"Programmierung","n":1}}},{"i":16,"$":{"0":{"v":"Diskrete Strukturen","n":0.707}}},{"i":17,"$":{"0":{"v":"Algebraische Strukturen","n":0.707}}},{"i":18,"$":{"0":{"v":"Gruppen","n":1},"1":{"v":"## Strukturen und Verknüpfungen\n**Definition:** Eine *Verknüpfung* auf einer Menge $M$ ist eine Abbildung\n$$\\begin{equation}\n    M \\times M \\rightarrow M\n\\end{equation}$$\nEine *algebraische Struktur* ist eine Menge mit ein oder mehreren Verknüpfungen.\n\n**Beispiele:**\n- \\- : $\\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z}, (x,y) \\mapsto x - y$ ist eine Verknüpfung auf $\\mathbb{Z}$.\n- $\\land$ ist eine Verknüpfung auf $B = \\{0,1\\}$ (wenn wir 0 und 1 als Wahrheitswerte definieren, und $\\land$ durch die zugehörige Wahrheitstafel definiert ist).\n- $7 \\mathbb{Z} = \\{7a \\mid a \\in \\mathbb{Z}\\} = \\{\\ldots, -14, -7, 0, 7, 14, \\ldots\\}$\n\n**Schreibweise:**\nEs seien $M$ eine Menge, $\\bullet$ eine Verknüpfung auf $M, m \\in M$, und $A,B \\subseteq M$.\n- $m \\bullet A := \\{m \\bullet a \\mid a \\in A\\} \\subseteq M$\n- $A \\bullet m := \\{a \\bullet m \\mid a \\in A\\} \\subseteq M$\n- $A \\bullet B := \\{a \\bullet b \\mid a \\in A, b \\in B\\} \\subseteq M$\n\n## Monoide\n**Definition:** Es sei $M$ eine Menge mit einer Verknüpfung:\n$$\\begin{equation}\n    \\bullet : M \\times M \\rightarrow M, (x,y) \\mapsto x \\bullet y\n\\end{equation}$$\n^monoide_axiome\n\nWir nennen $(M, \\bullet)$ ein *Monoid*, wenn folgende Axiome gelten:\n1. $(x \\bullet y) \\bullet z = x \\bullet (y \\bullet z)$ für alle $x,y,z \\in M$\n2. Es existiert ein $e \\in M$ mit $e \\bullet x = x = x \\bullet e$ für alle $x \\in M$ <br>\nDas Monoid heißt *abelsch* oder *kommutativ*, wenn zusätzlich gilt:\n3. $x \\bullet y = y \\bullet x$ für alle $x,y \\in G$.\n\nMan nennt 1. das Assoziativgesetz und 3. das Kommutativgesetz.\n\n**Bemerkung:** Das Element $e$ in 2. ist eindeutig und wird das *neutrale Element* von $M$ genannt. \n\n**Beispiele:**\nEs sei $A$ eine beliebige Menge, $B := \\{0,1\\}$.\n- $(\\mathbb{N}, +)$ ist kein Monoid, da 2. nicht gilt. \n- $(\\mathbb{Z}, -)$ ist kein Monoid, da 1. nicht gilt.\n- $(\\mathbb{N}_0, +)$ ist ein abelsches Monoid mit neutralem Element 0.\n- $(\\mathbb{R}, \\cdot)$ ist ein abelsches Monoid mit neutralem Element 1.\n- $(B, \\land)$ ist ein abelsches Monoid mit neutralem Element 1.\n\n## Inverse und Einheiten\n**Definition:** Es seien $(M, \\bullet)$ ein Monoid mit neutralem Element $e$ und $a \\in M$.\n- Gibt es $b \\in M$ mit $a \\bullet b = e$, so heißt $a$ *rechtsinvertierbar* und $b$ *rechtsinvers* zu $a$ bzw. $b$ ein *Rechtsinverses* von $a$.\n- Gibt es $b \\in M$ mit $b \\bullet a = e$, so heißt $a$ *linksinvertierbar* und $b$ *linksinvers* zu $a$ bzw. $b$ ein *Linksinverses* von $a$.\n- Ist $a$ sowohl links- als auch rechtsinvertierbar, so heißt $a$ eine *Einheit*. \n- Gibt es $b \\in M$ mit $b \\bullet a = e = a \\bullet b$, so heißt $a$ *invertierbar* und $b$ *invers* zu $a$ bzw. $b$ ein *Inverses* von $a$.\n\n## Gruppe\n**Definition:** Ein Monoid $(G, \\bullet)$, in dem alle Elemente invertierbar sind, heißt *Gruppe*. D.h. in einer Gruppe gilt:\n\n([[M3 | #^monoide_axiome]]) Für alle $x \\in G$ existiert $x' \\in G$ mit $x \\bullet x' = e = x' \\bullet x$\n\n**Beispiele:**\n- $(\\mathbb{Z}, +)$ ist eine abelsche Gruppe.\n- $(\\mathbb{N}_0, +)$ ist keine Gruppe, da ([[M3 | #^monoide_axiome]]) nicht gilt. \n- $(\\mathbb{R}, \\cdot)$ ist keine Gruppe, da ([[M3 | #^monoide_axiome]]) nicht gilt.\n- $(\\mathbb{R} \\backslash \\{0\\}, \\cdot)$ und $(R_{>0}, \\cdot)$ sind abelsche Gruppen. \n\n## Untergruppen ","n":0.045}}},{"i":19,"$":{"0":{"v":"Analysis für Informatiker","n":0.577}}}]}
